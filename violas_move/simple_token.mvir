module ViolasToken {

    import 0x00.LibraAccount;
    import 0x0.LibraCoin;
    import 0x00.Hash;
    import 0x0.U64Util;
    import 0x0.AddressUtil;
    import 0x0.BytearrayUtil;
    import 0x0.Vector;
        
    resource Owner {}

    // A resource representing the ViolasToken
    resource T {
        value: u64,
    }

    resource Info {
        magic: u64,
        token: address,
        allinone_events: LibraAccount.EventHandle<Self.AllInOneEvent>,
    }

    resource OwnerData {
        data: bytearray,
        owner: address,
        bulletins: Vector.T<bytearray>,
    }

    struct AllInOneEvent {
        etype: u64, 
        sender: address,
        receiver: address,
        token: address,
        amount: u64,
        price: u64,
        data: bytearray,
    }

    
    // Publishes an initial zero dToken to the sender.
    public publish() acquires Info {

        let sender: address;

        sender = get_txn_sender();

        if(exists<T>(copy(sender))) {
            return;
        }

        if (copy(sender) == 0x7257c2417e4d1038e1817c8f283ace2e1041b3396cdbb099eb357bbee024d614) {
            move_to_sender<Owner>(Owner{});
            move_to_sender<OwnerData>(OwnerData{ data: h"", owner: 0x7257c2417e4d1038e1817c8f283ace2e1041b3396cdbb099eb357bbee024d614, bulletins: Vector.empty<bytearray>() });
        }

        move_to_sender<T>(T{ value: 0 });

        move_to_sender<Info>(Info{
            magic: 123456789,
            token: 0x7257c2417e4d1038e1817c8f283ace2e1041b3396cdbb099eb357bbee024d614,
            allinone_events: LibraAccount.new_event_handle<Self.AllInOneEvent>(),
        });
        
        Self.emit_events(0, copy(sender), 0, 0, h"");
        
        return;
    }

    require_published() {
        let sender: address;
        let is_present: bool;
        sender = get_txn_sender();
        is_present = exists<T>(move(sender));
        assert(move(is_present), 101);
        return;
    }
    
    require_owner() {
        let sender: address;
        let is_present: bool;
        sender = get_txn_sender();
        is_present = exists<Owner>(move(sender));
        assert(move(is_present), 102);
        return;
    }

    // Mint new dTokens.
    mint(value: u64): Self.T {
        Self.require_published();
        Self.require_owner();
        return T{value: move(value)};
    }

    public mint_to_address(payee: address, amount: u64) acquires T, Info {

        let token: Self.T;
        token = Self.mint(copy(amount));
        
        // Mint and deposit the coin
        Self.deposit(copy(payee), move(token));

        Self.emit_events(1, copy(payee), copy(amount), 0, h"");
        
        return;
    }

    public mint_to_address_with_data(payee: address, amount: u64, data: bytearray) acquires T, Info {

        let token: Self.T;
        token = Self.mint(copy(amount));
        
        // Mint and deposit the coin
        Self.deposit(copy(payee), move(token));

        Self.emit_events(13, copy(payee), copy(amount), 0, move(data));
        
        return;
    }

    public zero(): Self.T {
        return T{ value: 0 };
    }

    value(coin_ref: &Self.T): u64 {
        return *&move(coin_ref).value;
    }
    
    // Returns an account's dToken balance.
    balance(): u64  acquires T {
        let sender: address;
        let token_ref: &Self.T;
        let token_value: u64;

        Self.require_published();
        
        sender = get_txn_sender();
        token_ref = borrow_global<T>(move(sender));
        token_value = *(&move(token_ref).value);

        return move(token_value);
    }

    // Deposit owned tokens to a payee's address
    deposit(payee: address, to_deposit: Self.T) acquires T {
        let sender: address;
        let amount: u64;
        
        let payee_token_ref: &mut Self.T;
        let payee_token_value: u64;
        let to_deposit_value: u64;

        Self.require_published();

        sender = get_txn_sender();
        
        payee_token_ref = borrow_global_mut<T>(copy(payee));
        payee_token_value = *(&copy(payee_token_ref).value);

        // Unpack and destroy to_deposit tokens
        T{ value: to_deposit_value } = move(to_deposit);

        amount = copy(to_deposit_value);
        
        // Increase the payees balance with the destroyed token amount
        *(&mut move(payee_token_ref).value) = move(payee_token_value) + move(to_deposit_value);

        return;
    }
    
    // Withdraw an amount of tokens of the sender and return it.
    withdraw(amount: u64): Self.T acquires T {
        let sender: address;
        let sender_token_ref: &mut Self.T;
        let value: u64;

        Self.require_published();

        sender = get_txn_sender();
        
        sender_token_ref = borrow_global_mut<T>(move(sender));
        value = *(&copy(sender_token_ref).value);

        // Make sure that sender has enough tokens
        assert(copy(value) >= copy(amount), 103);

        // Split the senders token and return the amount specified
        *(&mut move(sender_token_ref).value) = move(value) - copy(amount);
        return T{ value: move(amount) };
    }

    pay_from_sender(payee: address, amount: u64) acquires T {
        let sender: address;
        let to_pay: Self.T;

        Self.require_published();

        sender = get_txn_sender();
        
        to_pay = Self.withdraw(copy(amount));
        Self.deposit(copy(payee), move(to_pay));
        
        return;
    }

    public transfer(payee: address, amount: u64) acquires T, Info {
        Self.pay_from_sender(copy(payee), copy(amount));
        Self.emit_events(2, copy(payee), copy(amount), 0, h"");
        return;
    }

    public transfer_with_data(payee: address, amount: u64, data: bytearray) acquires T, Info {
        Self.pay_from_sender(copy(payee), copy(amount));
        Self.emit_events(12, copy(payee), copy(amount), 0, move(data));
        return;
    }
    
    public transfer_vcoin_with_data(payee: address, amount: u64, data: bytearray) acquires Info {
        LibraAccount.pay_from_sender(copy(payee), copy(amount));
        Self.emit_events(10, copy(payee), copy(amount), 0, move(data));
        return;
    }
    

    public record(data: bytearray) acquires Info {
        let sender: address;
        sender = get_txn_sender();
        Self.emit_events(11, copy(sender), 0, 0, move(data));
        return;
    }
    
    emit_events(etype: u64, receiver: address, amount: u64, price: u64, data: bytearray) acquires Info {

        let sender: address;
        let token: address;
        
        let allinone_event: Self.AllInOneEvent;
        
        let sender_info_ref: &mut Self.Info;
        let receiver_info_ref: &mut Self.Info;
        
        sender = get_txn_sender();
        token = 0x7257c2417e4d1038e1817c8f283ace2e1041b3396cdbb099eb357bbee024d614;

        allinone_event = AllInOneEvent {
            etype: copy(etype),
            sender: copy(sender),
            receiver: copy(receiver),
            token: copy(token),
            amount: move(amount),
            price: move(price),
            data: move(data),
        };

        sender_info_ref = borrow_global_mut<Info>(copy(sender));
        LibraAccount.emit_event<Self.AllInOneEvent>(&mut move(sender_info_ref).allinone_events, copy(allinone_event));
        
        if((copy(etype) == 1)   ||
           (copy(etype) == 2)   ||
           (copy(etype) == 5)   ||
           (copy(etype) == 8)   ||
           (copy(etype) == 10)  ||
           (copy(etype) == 12)  ||
           (copy(etype) == 13)  ||
           (copy(etype) == 14)  ||
           (copy(etype) == 15)  ||
           (copy(etype) == 16))
        {
            receiver_info_ref = borrow_global_mut<Info>(copy(receiver));  
            LibraAccount.emit_event<Self.AllInOneEvent>(&mut move(receiver_info_ref).allinone_events, copy(allinone_event));
        }
        
        return;
    }
    
}










